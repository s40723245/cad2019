<h1>Week</h1>
<p><a href="https://s40723245.github.io/cad2019/content/Week2-5.html">week2-5</a></p>
<p><a href="https://s40723245.github.io/cad2019/content/week6-9.html">week6-9</a></p>
<p><a href="https://s40723245.github.io/cad2019/content/week10-14.html">week10-14</a></p>
<p><a href="https://s40723245.github.io/cad2019/content/week15-18.html">week15-18</a></p>
<h2>Week2-5</h2>
<p><span size="4" style="font-size: large; color: #ff0000;">week1</span></p>
<p><span style="color: #ff0000;">中秋節放假</span></p>
<p><span size="4" style="font-size: large; color: #ff0000;"><span size="4" style="font-size: large;">week2</span></span></p>
<p>1.建立一個新的倉儲命名為cad2019</p>
<p>2.下載2b</p>
<p>3.更改start裡編譯器的路徑到隨身碟的201906fall的data</p>
<p>4.把倉儲從遠端拉到近端進行更新</p>
<p>5.git clone 個人倉儲網址.git</p>
<p>6.輸入git clone --recurse-submodules https://github.com/mdecourse/cmsimde.git cmsimde，載入cmsimde</p>
<p>7.進入cmsimde開啟倉儲 輸入python wsgi.py</p>
<p>8.如果flask沒更新，需輸入python -m pip install flask_cors，更新下載flask_cors</p>
<p>9.到up_dir複製檔案到cad2019目錄下</p>
<p>10.改完名字上傳即可</p>
<p>以下是我的操作教學影片</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/_k2VWUpOIsY" width="560"></iframe></p>
<p><span size="4" style="font-size: large; color: #ff0000;">week3</span></p>
<h4>編譯步驟:</h4>
<p>先將 Y:\portablegit\bin\sh.exe 改名為 sh_rename_for_solvespace.exe (透過 MSYS2 執行 shell 指令, 而非 portablegit 中的 sh.exe)</p>
<p>git version 查驗 git 版本</p>
<p>git 2.13 版本以上, 可以使用下列 git clone<span> </span><span>--recurse-submodules 取得所有子模組資料</span></p>
<p>git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace</p>
<p>上述指令同:</p>
<p>git clone <span><a href="https://github.com/solvespace/solvespace.git">https://github.com/solvespace/solvespace.git</a> </span></p>
<p><span>cd solvespace</span></p>
<p><span>git submodule init</span></p>
<p><span>git submodule update</span></p>
<p>edit Y:\tmp\solvespace\extlib\angle\CMakeLists.txt comment out line 713 and 714</p>
<p>#list(APPEND ANGLE_DEFINITIONS<br/>#"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \"d3dcompiler_47.dll\", \"d3dcompiler_46.dll\", \"d3dcompiler_43.dll\" }")<br/>endif()</p>
<p>接著需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中 (即隨身系統的 msys64\mingw64\lib 目錄):</p>
<p>cd solvespace</p>
<p>cd extlib</p>
<p>cd libpng</p>
<p>mkdir build</p>
<p>cd build</p>
<p>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release<br/>mingw32-make</p>
<p>(mingw32-make -Wl,-static)</p>
<p>rename libpng.dll.a to libpng_static.a and copy to Y:\msys64\mingw64\lib</p>
<p>接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行:</p>
<p><span>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release</span><br/><span>mingw32-make</span></p>
<p><span>編譯完成後, 可以在 build\bin 目錄中建立 solvespace.exe, 配合相關 dll 檔案後, 即可執行.</span></p>
<p><span size="4" style="font-size: large; color: #ff0000;">week4</span></p>
<p>自主練習</p>
<p><span size="4" style="font-size: large; color: #ff0000;">week5</span></p>
<p>solvespace操作</p>
<p>1.打開solvespace</p>
<p>2.畫出一個正方體</p>
<p>3.改顏色和透明度</p>
<p>4.儲存成html檔</p>
<p>5.把編譯過的text.html檔打開編譯</p>
<p>6.打指令</p>
<p>7.完成</p>
<p>以下是我的操作影片</p>
<p><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="//www.youtube.com/embed/6nf7AtP1cXo" width="560"></iframe></p>
<h2>week6-9</h2>
<p><span size="4" style="font-size: large; color: #ff0000;">week6</span></p>
<p>V-rep 網際 Python remote API ython remote API 雙輪車控制模擬</p>
<p><img caption="false" height="314" src="/images/1_Kr-r8E0ExCQeu4AyPNq1eg.gif" width="560"/></p>
<p></p>
<p><span size="4" style="font-size: large; color: #ff0000;">week7</span></p>
<p>零件18</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/bCLTkb9Ieg0" width="560"></iframe></p>
<p><span size="4" style="font-size: large; color: #ff0000;">week8</span></p>
<p><span style="color: #000000;">ssh連線鑰匙</span></p>
<h2>week10-14</h2>
<p><span size="4" style="font-size: large; color: #ff0000;">week10</span></p>
<p><span size="4" style="font-size: large;"><span size="4" style="font-size: large;">進行Solidworks, NX, Inventor 與 Creo (Pro/E) 的開發緣起/套件安裝/設定流程/零組件繪圖的相關差異與特點分析</span></span></p>
<p>Solidwork:這套CAD軟體幾乎每一年都有在改良，在它剛推出時就因價格低廉又好上手的強大吸引力，大受好評。</p>
<p>NX:是這4套CAD軟體中最早出身的，它比較適合用在繪製模具那種高精度的物品。</p>
<p><span>Inventor:目前它是最便宜的3D CAD軟體，性質上跟solidworks差不多。</span></p>
<p><span>Creo (Pro/E):<span>作為當今世界機械</span><span>CAD/CAE/CAM</span><span>領域的新標準而得到業界的認可和推廣，是現今主流的模具和產品設計三維</span><span>CAD/CAM</span><span>軟件之一。</span></span></p>
<p><span size="4" style="font-size: large; color: #ff0000;">week11</span></p>
<p><span size="4" style="font-size: large;">Solidworks操作影片</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/SLB6WYHcBDw" width="560"></iframe></p>
<p><span size="4" style="font-size: large;"><span size="4" style="font-size: large;"></span></span></p>
<p><span size="4" style="font-size: large; color: #ff0000;">week12</span></p>
<p><span size="4" style="font-size: large;"><span size="4" style="font-size: large;">NX12第9章－製造</span></span></p>
<p><span size="3" style="font-size: medium;"><br/><strong>9.1開始</strong><br/>在將每個CAD模型移入模型之前，需要執行一些準備步驟。<br/>CAM環境。在本章中，我們將使用在以前的運動問題。在此模型中，所有單位均以毫米為單位，並且組件的製造。在開始之前，如果可以成為CAM高級角色。為此，請轉到角色資源欄上的菜單。單擊內容和列表將彈出可供CAM Advanced角色使用的選項<br/><strong>9.1.1創建空白</strong><br/>➢在第4章中打開文件Die_cavity.prt以解決運動問題<br/>➢要創建坯料，請插入以下尺寸的塊<br/>長度= 150毫米<br/>寬度= 100毫米<br/>高度= 80毫米<br/>➢對於“原點”選項，選擇基本塊的最低角，以便新創建的塊可以包裝整個以前的模型，該塊包含整個設計部分，因此我們需要更改該塊的顯示屬性以獲得更好的可視化效果。<br/>➢單擊視圖選項卡的可視化組中的編輯對象顯示圖標<br/>➢選擇剛創建的塊，然後單擊確定。<br/>➢彈出窗口時，更改顯示顏色並將透明度更改為50<br/>➢點擊確定<br/>➢右鍵單擊零件瀏覽器中的塊，然後隱藏剛剛創建的塊。<br/>單擊“隱藏”（可能需要使用“從列表中選擇...”來選擇空白）。這將使原始塊將從工作環境中消失。<br/><strong>9.1.2設置加工環境</strong><br/>現在我們準備進入製造模塊。<br/>➢選擇文件→新建→製造→銑削車削<br/>➢有許多不同的定制CAM模板可用於不同的加工<br/>操作。在這裡，我們僅對銑削操作感興趣。<br/><strong>9.1.3操作導航器</strong><br/>➢單擊資源欄左側的“操作導航器”選項卡<br/>操作導航器提供有關已創建程序和相應程序的信息<br/>有關刀具，方法和策略的信息。程序列表可以用不同的方式查看<br/>分類列表。在“操作導航器”中有四種查看程序列表的方法，<br/>它們是“程序順序”視圖，“機床”視圖，“幾何”視圖和“加工方法”視圖。<br/>➢單擊幾何視圖<br/><strong>9.1.4機器坐標系（MCS）</strong><br/>➢單擊插入組中的創建幾何圖標<br/>啟動編程設置<br/>將看到“創建幾何體”彈出對話框。<br/>➢點擊確定<br/>另一個彈出窗口將允許設置MCS<br/>哪裡都行。默認情況下，NX 12採用原始<br/>絕對CS作為MCS。<br/>➢單擊確定選擇默認選項作為MCS<br/><strong>9.1.5幾何定義</strong><br/>➢單擊幾何視圖<br/>➢通過在操作導航器中單擊“ +”號來展開MCS_MAIN_SPINDLE<br/>➢在操作導航器中雙擊WORKPIECE_MAIN。如果看不到<br/>嘗試點擊相關的“ +”號<br/>彈出窗口Workpiece Main<br/>出現。可以在此處分配<br/>零件幾何，毛坯幾何和<br/>檢查幾何。<br/>➢單擊零件圖標<br/>➢選擇設計部分，然後單擊<br/>➢單擊空白圖標<br/>➢單擊塊，然後按確定<br/>➢單擊確定退出工件主窗口</span></p>
<p><span size="4" style="font-size: large;"><span size="4" style="font-size: large;">9.2創建操作</span></span></p>
<p><span size="3" style="font-size: medium;"><br/><strong>9.2.1創建新操作</strong><br/>➢單擊工具欄中的創建操作圖標<br/>彈出創建操作窗口。<br/>➢確保操作類型為Mill_Contour<br/>➢單擊左上方的Cavity_Mill圖標，如下所示：<br/>➢選擇程序為1234<br/>➢將幾何更改為WORKPIECE_MAIN<br/>➢點擊確定<br/>通過序列。<br/><strong>9.2.2工具創建和選擇</strong><br/>➢在型腔銑削彈出菜單中，單擊“工具”對話框中的“新建”按鈕。<br/>➢點擊新建<br/>➢在新工具窗口中，選擇銑削圖標<br/>➢輸入BUEM12X1作為名稱並單擊<br/>➢輸入如下圖所示的值<br/>➢點擊確定<br/>9.2.3工具路徑設置<br/>確保“工具軸”垂直於塊的頂面。<br/>➢單擊工具軸，然後選擇指定向量<br/>➢如圖所示選擇合適的軸<br/>➢在腔銑刀菜單中，單擊路徑<br/>設置選項<br/><strong>9.2.4跨步和扇貝高度</strong><br/>選擇了“跨步”選項。這些選項包括“常量”、“扇貝”，<br/>工具直徑等。例如，“常數”要求輸入下一行的距離值。<br/>扇貝高度根據最大高度控制平行通道之間的距離<br/>指定在通過之間保留的材料（扇貝）。這受刀具定義的影響<br/>和曲面的曲率。扇貝允許系統確定跨步距離<br/>根據輸入的扇貝高度。<br/>➢對於Stepover，選擇％Tool Flat，然後將Percent更改為70<br/><strong>9.2.5每次切割深度</strong><br/>➢將每次切割的通用深度值更改為0.5<br/>➢點擊削減水平<br/>➢將範圍類型更改為用戶定義<br/>➢將範圍深度更改為80<br/>➢選擇確定<br/><strong>9.2.6切削參數</strong><br/>➢在路徑設置菜單上，單擊切割<br/>➢在策略選項卡按鈕下，更改剪切<br/>➢單擊股票選項卡<br/>➢將零件側庫存的值更改為0.5<br/>➢點擊確定<br/><strong>9.2.7迴避</strong><br/>➢單擊非切割動作<br/>➢單擊迴避標籤<br/>該窗口由以下幾個避免點組成：<br/>我們關注以下幾點：<br/>從起點這是換刀命令的關鍵點進行。該值通常是50或100<br/>Z = 0高度以上mm，以增強安全性<br/>自動工具更換切刀時的工作<br/>轉換器（ATC）。<br/>➢點擊起點<br/>➢在點選項字段中選擇指定<br/>➢在點對話框中，輸入坐標<br/>XC，YC和ZC為（0、0、50）<br/>➢點擊確定<br/>這是程序開始和結束的地方。該值也比<br/>Z = 0級別可增強安全性。這也是機器操作員檢查高度的地方<br/>相對於作業的Z = 0級別安裝在主軸上的刀具。此交叉檢查<br/>在機床中輸入的刀具補償。<br/>➢單擊起點<br/>➢選擇指定<br/>➢在點對話框中輸入坐標（0，0，50）<br/>➢單擊確定退出點構造器<br/>➢單擊轉移/快速選項卡<br/>➢在間隙選項中選擇平面<br/>➢從類型選項卡的下拉菜單中選擇XC-YC平面<br/>➢在偏移和參考標籤下，輸入<br/>值3作為距離<br/>➢單擊兩次“確定”返回到腔磨機<br/>參數窗口<br/><strong>9.2.8速度和進給</strong><br/>➢選擇進給和速度輸入進給和速度參數<br/>➢輸入主軸轉速值為4500 rpm<br/>單個程序中涉及許多feed。<br/>最重要的是切削飼料。進給時，工具將與原始工件並實際上切掉材料工件。<br/>它是相對線速度刀具相對於作業移動的位置。<br/>其他提要是可選的。一些機器控制系統使用其默認的回退和移動進給。在在這些情況下，即使沒有輸入其他提要，就不會有任何問題。一些控制系統可能會從程序。它可能比機器的略小最大進給速度。<br/>➢輸入Cut值為1200 mmpm<br/>➢點擊確定</span></p>
<p><strong><span size="4" style="font-size: large;"><span size="4" style="font-size: large;">9.3程序生成和驗證</span></span></strong></p>
<p><span size="3" style="font-size: medium;"><br/><strong>9.3.1生成程序</strong><br/>現在我們完成了輸入所需的所有參數<br/>用於粗加工程序。現在是時候生成<br/>程序。<br/>➢單擊工具欄底部的“生成”圖標。<br/>窗口<br/>現在可以觀察對模型進行切片的軟件<br/>切入深度並在每個級別上創建刀具路徑。<br/>可以在模型上找到青色，藍色，紅色和黃色<br/>如圖所示。<br/><strong>9.3.2刀具路徑顯示</strong><br/>每當想查看刀具的整個刀具路徑時<br/>程序，在“操作”中右鍵單擊該程序<br/>導航器，然後單擊重播。它將顯示為可以觀察到“操作導航器”中該程序的旁邊是黃色的驚嘆號而不是紅色標記。這意味著程序已成功生成，但尚未生成<br/>經過後期處理。如果模型有任何更改，程序將再次帶有紅色標記在它的旁邊。這意味著必須再次生成程序。但是，沒有必要更改程序中的任何參數。<br/><strong>9.3.3刀具路徑模擬</strong><br/>檢查創建的程序非常重要。這樣可以防止任何不當和<br/>在切割路徑中進行危險動作。錯誤的參數和設置將給工件造成高昂的損壞。為避免此類錯誤，NX 12提供工具路徑驗證和鑿檢查。刀具路徑驗證可用於查看整個程序中的刀具運動。可以觀察工具的嚙合方式以及切割後的縮回方式。它還顯示了實際材料通過圖形模擬刪除。還可以通過以下方式查看特定的關注區域移動程序行。<br/>➢在Operation Navigator中右鍵單擊該程序，然後選擇Tool Path→V陶醉<br/>或單擊工具欄中的“驗證工具路徑”按鈕<br/>這將允許設置用於可視化工具路徑的參數。<br/>➢在工具路徑可視化窗口中，單擊<br/>在播放圖標上查看動作<br/>還可以在不同模式下查看可視化<br/>通過更改旁邊的下拉菜單中的選項<br/>顯示。<br/>➢單擊同一頁面上的3D動態選項卡<br/>窗口<br/>➢單擊同一頁面上的“顯示選項”按鈕<br/>窗口<br/>➢將動作數更改為50<br/>➢將動畫精度更改為精細<br/>➢將IPW顏色更改為綠色<br/>➢點擊確定<br/>➢再次單擊播放按鈕<br/>模擬將如下圖所示<br/>正確的。使用此選項，將能夠查看<br/>實際的切削模擬和材料去除<br/>通過計算機圖形學。它是3D動態的<br/>可以在模擬時旋轉，平移和縮放模擬<br/>正在玩。<br/><strong>9.3.4鑿檢查</strong><br/>切屑檢查用於驗證刀具是否從工件上去除了零件幾何形狀上多餘的材料。考慮到設計公差，任何製造過程<br/>可能通過兩種方式生產有缺陷的零件。一種是去除多餘的材料，也稱為<br/>更少的材料條件。另一種是留下應該清除的材料<br/>是更多的物質條件。在大多數情況下，前者更危險，因為不可能<br/>重新設計部分。後者更安全，因為可以通過返工去除殘留的材料<br/>那個部分。鑿檢查選項檢查<br/>前一種情況是多餘的材料清除<br/>將被識別。<br/>➢右鍵單擊操作中的程序<br/>航海家<br/>➢選擇工具路徑→鑿檢查<br/>➢點擊確定<br/>鑿檢查完成後，刀具路徑<br/>報告窗口將彈出。如果有的話<br/>找到鑿子，就要糾正程序。<br/>除此以外，<br/>➢單擊確定或直接關閉彈出窗口</span></p>
<p><strong><span size="4" style="font-size: large;"><span size="4" style="font-size: large;">9.4操作方法</span></span></strong></p>
<p><span size="3" style="font-size: medium;"><br/><strong>9.4.1粗加工</strong><br/>對於銑削操作，在完成作業之前，首先應進行粗銑削。<br/>粗加工的主要目的是以更快的速度去除散裝物料，而不會影響<br/>準確性和工作完成度。給予庫存津貼以為生產提供足夠的材料。<br/>完成操作以獲得準確和良好的完成工作。我們在上一部分中所做的<br/>本章正在生成粗加工程序。現在我們必須適度消除所有不平整<br/>上一個程序剩餘的材料。<br/>9.4.2半精加工<br/>半精加工程序旨在消除由於粗加工引起的不均勻<br/>並為精加工工序保留部分庫存津貼。一旦我們完成了第一個<br/>粗加工程序中，半精加工總是更容易執行。<br/>現在，我們將第一個程序複製並粘貼到Operation Navigator中。在新程序中<br/>只需要更改一些參數和切削刀具尺寸，然後重新生成<br/>程序。<br/>➢右鍵單擊CAVITY_MILL程序<br/>操作導航器，然後單擊複製<br/>➢再次右鍵單擊CAVITY_MILL，然後<br/>選擇粘貼<br/>➢右鍵單擊第二個<br/>剛創建的CAVITY_MILL_COPY，然後單擊重命名<br/>➢將第二個程序重命名為CAVITY_MILL_1<br/>會看到新創建的CAVITY_MILL_1旁邊有一個紅色標記，表示<br/>該程序未生成。<br/>現在讓我們設置第二個程序需要更改的參數。在開始之前，我們<br/>應該分析零件的幾何形狀以找出刀具直徑的最小角半徑。<br/>在我們的模型中為5毫米，在地板邊緣為1毫米。因此，刀具直徑可以是<br/>小於10毫米的任何物體。為了獲得最佳的輸出和剛性，我們將選擇帶有<br/>直徑10，下半徑1。<br/>➢在Operation Navigator上雙擊CAVITY_MILL_1以打開參數<br/>窗口<br/>就像在上一個程序中一樣，我們將創建一個新刀具。在工具標籤中，將看到<br/>首先選擇的刀具。它將顯示BUEM12X1作為當前工具。<br/>➢創建一個新的工廠並命名為BUEM10X1<br/>➢直徑應小於10<br/>半徑為1，長笛長度為38<br/>➢點擊確定<br/>➢單擊每次切割的公共深度為0.25英寸<br/>路徑設置<br/>➢然後單擊切割參數按鈕<br/>➢單擊股票選項卡<br/>➢取消選中與使用地板相同旁邊的框<br/>側<br/>➢輸入0.25作為零件庫存<br/>➢輸入0.1作為零件底盤存貨<br/>➢單擊遏制選項卡按鈕<br/>➢在“在製品中”旁邊的下拉菜單中，選擇“使用3D”。<br/>In Process Workpiece是NX中非常有用的選項。該軟件考慮了先前的程序<br/>並生成當前程序，例如在無材料區域沒有不必要的切削運動。這種策略大大減少了切割時間和空氣切割運動。的<br/>該算法將強制切刀僅去除之前的材料<br/>計劃並保持當前零件庫存限額。<br/>➢選擇確定以返回到參數窗口<br/>➢單擊提要和速度<br/>➢輸入主軸轉速5000<br/>➢然後點擊確定<br/>半成品程序的參數和設置完成。<br/>➢通過單擊生成圖標重新生成程序<br/>➢軟件生成完成後，單擊確定。<br/>然後重播“工具路徑可視化”。第二個程序中生成的整體刀具路徑<br/>如下圖所示。可以重播它或以類似方式檢查氣刨。<br/><strong>9.4.3整理概況</strong><br/>到目前為止，我們已經完成了零件的粗加工和半精加工程序。有一個小<br/>工件中剩餘的材料量，可在精加工程序中去除，以獲得<br/>所需的精確零件幾何形狀。整理程序應生成為<br/>零件的表面應正確加工。因此，最好創建多個<br/>程序以獨特的方式加工具有相關切削參數和策略的表面集，而不是<br/>而不是為所有曲面編寫一個程序。以下內容說明瞭如何對配置文件進行分組和<br/>表面並創建塗飾程序。<br/><strong>9.4.3.1外部輪廓</strong><br/>該程序旨在將外斜牆修整到地板的底部。因為<br/>該程序不應觸摸頂部的輪廓表面，我們將進行“檢查並修剪”<br/>程序中的邊界。<br/>➢重複與之前相同的步驟，在操作上複製並粘貼CAVITY_MILL_1<br/>航海家<br/>➢重命名程序CAVITY_MILL_2<br/>➢雙擊CAVITY_MILL_2進行參數更改<br/>➢在彈出的參數窗口中，將“剪切樣式”更改為“輪廓”，然後將“步進”更改為<br/>佔40％<br/>➢單擊指定修剪邊界選項卡<br/>修剪邊界窗口將彈出。確保<br/>在右邊執行以下步驟<br/>序列。保持Trim Side的默認設置為<br/>內。這告訴軟件切刀不應<br/>在邊界內的任何地方切割材料。修剪允許<br/>可以指定邊界，以進一步限制每個切割級別的切割區域。<br/>➢將選擇方法更改為曲線<br/>➢將平面從自動更改為指定，然後單擊平面對話框<br/>將會彈出一個新窗口。窗口將詢問選擇飛機的模式<br/>曲線應投影。通常應該在零件的最高點<br/>幾何。準確地說，它應該在MCS上。<br/>➢從類型下的下拉菜單中選擇XC-YC平面<br/>➢在距離旁邊輸入3<br/>➢點擊確定<br/>現在我們將開始從零件中選擇邊。這些選定的邊將投影在Z =<br/>3平面作為曲線並用作邊界。<br/>➢如圖所示，沿著輪廓表面選擇牆的所有頂部外邊緣。<br/>確保連續選擇所有8條邊線<br/>➢選擇確定<br/>➢輸入每次切割的通用深度為0.2<br/>➢點擊切割參數<br/>➢在彈出對話框中，單擊“股票”選項卡<br/>➢輸入零件側面庫存和零件底面庫存值為0.00<br/>Intol允許指定最大距離<br/>切割器可能偏離預期的路徑進入<br/>工件。<br/>Outtol允許指定最大距離<br/>刀具可能會偏離預期的路徑而遠離<br/>工件。<br/>➢輸入Intol和Outtol值為0.001<br/>如圖所示<br/>➢點擊確定<br/>➢單擊生成圖標以生成<br/>主參數窗口中的程序<br/>➢當<br/>程序生成完成<br/>外部輪廓的精加工程序現已準備就緒。可以在重放工具時觀察<br/>切刀永遠不會越過為修剪和檢查所給定邊界的路徑。切刀<br/>縮回Z = 3平面以進行重定位。<br/>9.4.3.2內部輪廓<br/>➢重複與之前相同的步驟，在操作上複製並粘貼CAVITY_MILL_2<br/>導航器並將其重命名為CAVITY_MILL_3<br/>➢雙擊CAVITY_MILL_3以編輯參數或右鍵單擊它並選擇Edit<br/>➢選擇“指定修剪邊界”選項卡，然後在彈出窗口中選擇“修剪邊在外部”<br/>對話框<br/>這樣可以防止切刀通過邊界。<br/>➢將選擇方法更改為曲線<br/>➢手動將平面更改為XC-YC平面，並將偏移距離輸入為3<br/>➢點擊確定<br/>➢如圖所示，選擇沿輪廓表面的所有頂部內邊緣。再次，使<br/>確保所有8條邊都被選中以連續的順序（使用Shift +單擊以取消選擇曲線）。<br/>➢選擇確定返回參數窗口<br/>➢生成程序<br/>➢生成完成後，單擊確定。<br/>內部輪廓的精加工程序現已準備就緒。通過重播工具路徑，可以<br/>觀察到切刀永遠不會越過修剪和檢查所給定的邊界。<br/><strong>9.4.4修整輪廓表面</strong><br/>現在，我們將使用其他類型的策略來完成頂部自由曲面。<br/>➢單擊工具欄中的創建操作圖標<br/>➢單擊固定輪廓圖標為<br/>如圖所示<br/>➢選擇1234作為程序<br/>➢選擇WORKPIECE_MAIN作為<br/>幾何<br/>➢保留程序的默認名稱<br/>➢點擊確定<br/>➢在參數窗口的驅動方法下，確保已選擇邊界<br/>➢單擊圖標，這將彈出“邊界驅動方法”窗口，然後單擊<br/>如圖所示，打開“邊界幾何”菜單<br/>➢將模式更改為曲線/邊線<br/>➢選擇材料面在外面<br/>➢選擇工具位置為開<br/>工具位置確定工具在接近邊界時如何定位自身<br/>會員。可以為邊界成員分配三個工具位置之一：“打開”，“ Tanto”或“接觸”。<br/>•在“打開”位置，工具的中心點與沿工具軸的邊界對齊或<br/>投影向量。<br/>•在Tanto位置，工具的側面與邊界對齊。<br/>•在“接觸”位置，工具接觸邊界。<br/>➢對於飛機，選擇“用戶定義”<br/>➢再次將平面設置為XC-YC，距離為3<br/>➢點擊確定<br/>➢如圖所示，選擇頂部輪廓表面的外環。記得選擇<br/>邊緣連續<br/>➢點擊確定<br/>我們已在循環外部修剪了幾何圖形。現在我們必須修剪內部的幾何<br/>內部循環，這樣剩下的唯一幾何圖形就是兩個循環之間的區域。<br/>➢選擇模式為曲線/邊線<br/>➢選擇材料面為內側，工具位置為開<br/>➢在XC-YC上選擇用戶定義的平面，距離為3<br/>➢如圖所示選擇輪廓表面的內邊緣<br/>➢單擊確定返回到邊界驅動方法窗口<br/>➢將Stepover方法更改為Scallop，輸入高度為0.001，然後單擊OK。<br/>➢點擊切割參數<br/>➢在庫存選項卡中更改容差值，以便<br/>零件總和零件總和是0.001<br/>➢單擊更多選項卡按鈕並輸入值<br/>最大步長為1.0<br/>➢點擊確定<br/>在主要參數窗口中，<br/>➢創建一個新工具並將其命名為BEM10<br/>➢將直徑更改為10毫米或更小<br/>半徑為5毫米。<br/>➢點擊確定<br/>➢單擊工具欄上的Feeds and Speeds圖標。<br/>參數窗口<br/>➢輸入主軸轉速，進給速度（切削）和<br/>如圖所示計算其他<br/>對<br/>➢點擊確定<br/>➢生成程序<br/>輪廓表面現已完成，可以查看<br/>通過刀具路徑驗證進行仿真。<br/><strong>9.4.5地板</strong><br/>地板是在地板上執行的整理操作<br/>零件的水平平面（地板）。在大多數<br/>銑削過程中，地板將是最終的<br/>他們的運作。所有的水平面將<br/>完成。這種平面操作使切刀在<br/>每張臉都單次通過。<br/>➢單擊創建操作圖標<br/>➢在頂部將類型更改為mill_planar<br/>窗戶的<br/>➢更改所有選項，如圖所示<br/>➢點擊確定<br/>➢在參數窗口中，更改剪切<br/>跟隨模式<br/>➢更改以下刀具直徑的百分比<br/>步入40<br/>在地板操作中，最好始終保持<br/>步進值小於直徑的一半<br/>刀具以在平面上獲得更大的平整度<br/>表面。<br/>與以前的程序不同，我們必須選擇一個剪切區域。<br/>➢單擊“指定切割區域地板”，如圖所示<br/>➢選擇顯示在<br/>下圖<br/>如果無法選擇如圖所示的表面<br/>轉到零件導航器並隱藏空白（選擇<br/>空白，可以右鍵單擊空白，使用選擇<br/>列表...），選擇曲面並再次取消隱藏毛坯。<br/>➢點擊確定<br/>➢在主參數窗口中單擊切割參數<br/>➢選擇庫存選項卡按鈕並輸入Intol和Outtol值為0.001<br/>➢點擊確定<br/>➢單擊提要和速度<br/>在“參數”主窗口中，<br/>➢創建一個新工具並將其命名為BEF105<br/>➢將直徑更改為10毫米或更小<br/>半徑為5毫米<br/>➢點擊確定<br/>因為這是地板操作，所以最好將主軸轉速高，進給速度低<br/>到以前的操作。<br/>➢輸入主軸速度，進給速度的值<br/>（剪切）併計算其他值，如<br/>數字<br/>➢選擇確定<br/>➢生成程序。然後重播並驗證<br/>切刀路徑<br/>下圖顯示了地板的“刀具路徑”顯示。<br/><strong>9.5後期處理</strong><br/>製造應用程序的主要用途是生成製造的工具路徑<br/>部分。通常，我們不能僅將未修改的刀具路徑文件發送到機器並開始切割<br/>因為有許多不同類型的機器。每種機器都有獨特的硬件<br/>功能，要求和控制系統。例如，機器可能具有垂直或垂直<br/>臥式主軸它可以在同時移動多個軸的同時進行切割等。控制器接受<br/>工具路徑文件，並指示工具運動和其他機器活動（例如轉動冷卻液或<br/>空氣）。<br/>自然，每種類型的機器都有獨特的硬件特性；控制器在以下方面也有所不同<br/>軟件特性。例如，大多數控制器都要求將<br/>冷卻液在特定代碼中給出。一些控制器還限制了M代碼的數量，<br/>在一行輸出中被允許。此類信息不在最初的NX工具路徑中。<br/>因此，必須修改刀具路徑以適合每種不同的獨特參數。<br/>機器/控制器組合。修改過程稱為後處理。結果是<br/>後處理的刀具路徑。<br/>生成最終的後加工刀具路徑涉及兩個步驟。<br/>1.創建刀具路徑數據文件，或稱為CLSF（刀具位置源文件）。<br/>2.將CLSF後處理為機器CNC代碼（後處理文件）。該程序讀取<br/>工具路徑數據並將其重新格式化以用於特定機器及其隨附工具<br/>控制器。<br/><strong>9.5.1創建CLSF</strong><br/>生成並保存操作後，將生成的刀具路徑存儲為操作的一部分<br/>在零件文件中。 CLSF（刀具位置源文件）提供了複製這些內部文件的方法<br/>從零件文件中的操作到CLSF中的工具路徑（即文本文件）的路徑。的<br/>GOTO值是當前刀具路徑的“快照”。導出的值引用自<br/>操作中存儲的MCS。 CLS文件是某些後續程序的必需輸入，<br/>例如後處理器。<br/>➢單擊以下程序之一<br/>想在<br/>操作導航器<br/>➢點擊輸出CLSF<br/>操作工具欄<br/>將會彈出一個窗口以選擇CLSF<br/>格式。<br/>➢選擇CLSF_STANDARD並<br/>輸入文件的位置<br/>➢選擇確定<br/>將創建CLSF文件。會類似於圖<br/>下面。文件內容包含刀具的基本代碼<br/>運動，沒有任何有關機器代碼和控制的信息<br/>系統。該文件可用於任何機器的後處理<br/>控制。文件的擴展名是.cls。<br/>已輸出到CLSF或後處理的任何程序的下一個綠色複選標記<br/>在“操作導航器”中對其進行操作。<br/><strong>9.5.2後處理</strong><br/>➢在操作導航器中單擊要發布的程序<br/>➢單擊菜單→工具→操作導航器→輸出→後處理或從<br/>主頁選項卡，如圖所示<br/>➢選擇MILL_3_AXIS機器並<br/>輸入文件的位置<br/>➢選擇確定<br/>這將為目標計算機創建後處理文件。可以找到塊號<br/>帶有與機器控制器類型有關的G和M代碼。文件的擴展名是.ptp。<br/>最終輸出（filename.ptp）文件可以傳輸到用於進行實際銑削的機器<br/>操作。從模型轉移到製造開始的整個過程<br/>模塊將文件傳輸到機器，並將原始零件加工成最終零件<br/>被稱為計算機輔助製造</span></p>
<p><strong><span size="4" style="font-size: large;"><span size="4" style="font-size: large;">Webots操作影片</span></span></strong></p>
<p>1.一開始先點start_webots.bat開啟webots</p>
<p>2.創立新世界並改名成my_first_simulation</p>
<p>3.再來設定一些東西(詳情如以下影片查看)</p>
<p>4.建立木箱並設定尺寸、位置</p>
<p>5.新增一個E-puck robot(電子冰球機器人)</p>
<p>6.測試物理施力會對木箱或機器人有什麼反應</p>
<p>7.導入程式碼讓機器人照著程式走</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/YUBlyTBo_P0" width="560"></iframe></p>
<p><span size="4" style="font-size: large;"><span style="color: #ff0000;">week13</span>  </span></p>
<p><strong><span size="4" style="font-size: large;">我的reveal報告</span></strong></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/VO4bPbI6ZxQ" width="560"></iframe></p>
<h2>week15-18</h2>
<p><span style="color: #ff0000;"><big>week15查驗</big></span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/9RxsQPFrlzk" width="560"></iframe></p>
<p><span><span style="color: #00ffff;">心得</span>：在這學期我學到了許多東西，從一開始solidworks的繪圖到現在webots tutorial操作，要看懂NX原文書花了很多時間，不過持之以恆到最後我相信一定會有所成果。雖然我的進度比較慢，不過會慢慢跟上進度的。</span></p>
<p><span style="color: #ff0000;"><big>w17協同任務</big></span></p>
<p><span style="color: #000000;">It is very important to always do this, and specially when your dynamic model doesn't behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their name.</span></p>
<div class="tlid-input input">
<div class="source-wrap">
<div class="input-full-height-wrapper tlid-input-full-height-wrapper">
<div class="source-input">
<div class="source-footer-wrap source-or-target-footer">
<div class="source-footer">
<div class="speech-wrap source-or-target-footer-button left-positioned">
<div aria-disabled="false" aria-label="開啟語音輸入功能" aria-pressed="false" class="speech-button goog-toolbar-button" data-tooltip="開啟語音輸入功能" data-tooltip-align="t,c" id="gt-speech" role="button" tabindex="0"><span class="jfk-button-img"></span></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="text-wrap tlid-copy-target">
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">始終執行此操作非常重要，尤其是在動態模型無法按預期運行時，為了快速調試模型，尤其如此。同樣，在仿真過程中請始終查看場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖標。</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways:</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">最後，我們需要準備機器人，以便我們可以輕鬆地將抓取器連接到它，或輕鬆地將機器人連接到移動平台（例如）。可以通過兩種不同的方式將兩個動態啟用的形狀嚴格地彼此附加：</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">• by grouping them: select the shapes, then [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Group selected shapes].<br/>• by attaching them via a force/torque sensor: a force torque sensor can also act as a rigid link between two separate dynamically enabled shapes.</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">•通過對它們進行分組：選擇形狀，然後選擇[菜單欄-&gt;編輯-&gt;分組/合併-&gt;對選定形狀進行分組]。<br/>•通過力/扭矩傳感器進行連接：力扭矩傳感器還可以充當兩個單獨的動態啟用形狀之間的剛性鏈接。</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">In our case, only option 2 is of interest. We create a force/torque sensor with [Menu bar --&gt; Add --&gt; Force sensor], then move it to the tip of the robot, then attach it to object robot_link_dyn6. We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its name to robot_attachment:</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">在我們的情況下，只有選項2是有意義的。我們使用[菜單欄-&gt;添加-&gt;力傳感器]創建一個力/扭矩傳感器，然後將其移動到機器人的尖端，然後將其附加到對象robot_link_dyn6。我們會適當地更改其尺寸和外觀（紅色力/扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們還將其名稱更改為robot_attachment：</div>
<div class="result-shield-container tlid-copy-target" tabindex="0">Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the Assembling/disassembling toolbar button. The gripper goes into place:</div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">現在，我們將抓手模型拖到場景中，使其保持選中狀態，然後按住Control鍵單擊並單擊附著力傳感器，然後單擊“裝配/拆卸”工具欄按鈕。夾持器到位：</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">The gripper knew how to attach itself because it was appropriately configured during its model definition. We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click Assembling in the object common properties. Set an empty string for 'Parent' match values, then click Set matrix. This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point. To verify that we did things right, we drag the model Models/robots/mobile/KUKA Omnirob.ttm into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the Assembling/disassembling toolbar button. Our robot should correctly place itself on top of the mobile robot:</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。我們選擇機器人模型，然後在對象公共屬性中單擊“組裝”。為“父項”匹配值設置一個空字符串，然後單擊“設置矩陣”。這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位/定向。為了驗證我們做的正確，我們將模型Models / robots / mobile / KUKA Omnirob.ttm拖到場景中。然後，我們選擇機器人模型，然後在移動平台上按住Control鍵並單擊其中一個附接點，然後單擊“組裝/拆卸”工具欄按鈕。我們的機器人應該正確地將自己放置在移動機器人的頂部：</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach embedded scripts to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand how object handles are accessed from embedded scripts. We can also control/access/interface our model from a plugin, from a remote API client, from a ROS node, from a BlueZero node, or from an add-on.<br/>Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --&gt; File --&gt; Save model as...]. If we saved it in the model folder, then the model will be available in the model brower.</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">現在，我們可以向機器人添加其他項目，例如傳感器。在某些時候，我們可能還希望將嵌入式腳本附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。在這種情況下，請確保了解如何從嵌入式腳本訪問對象句柄。我們還可以通過插件，遠程API客戶端，ROS節點，BlueZero節點或附加組件來控制/訪問/接口模型。<br/>現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用[菜單欄-&gt;文件-&gt;將模型另存為...]。如果我們將其保存在模型文件夾中，則模型將在模型瀏覽器中可用。</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW"></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">webot</div>
<div class="result-shield-container tlid-copy-target" tabindex="0"></div>
<div class="result-shield-container tlid-copy-target" tabindex="0">Add Walls<br/>In order to verify your progression, implement by yourself four walls to surround the environment. The walls have to be defined statically to the environment. To understand the difference between static and dynamic, let's take a defined object (the ball) above the ground. If the Physics node is NULL, it will remain frozen in the air during the simulation (static case). If the physics field contains a Physics nodes, it will fall under the effect of gravity (dynamic case).</div>
<div class="result-shield-container tlid-copy-target" tabindex="0">
<div class="tlid-results-container results-container">
<div class="tlid-result result-dict-wrapper">
<div class="result tlid-copy-target">
<div class="text-wrap tlid-copy-target">
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">添加牆<br/>為了驗證您的進度，請自己實施四堵牆以包圍環境。必鬚根據環境靜態定義牆壁。要了解靜態和動態之間的區別，我們將定義的物體（球）放在地面上方。如果“物理”節點為NULL，則在仿真過程中它將保持凍結狀態（靜態情況）。如果物理場包含“物理”節點，則它將受重力作用（動態情況）。</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">Use as much as possible the DEF-USE mechanism at the Shape level rather than at the Geometry level. Indeed it's more convenient to add an intermediate Shape node in the boundingObject field of the Solid node. The best Geometry primitive to implement the walls is the Box node. Only one Shape has to be defined for all the walls. The expected result is shown in this figure.</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">在Shape級別而不是Geometry級別，盡可能使用DEF-USE機制。實際上，在Solid節點的boundingObject字段中添加中間Shape節點更為方便。實現牆的最佳幾何原語是Box節點。所有牆壁僅需定義一個形狀。預期結果如圖所示</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">Hands-on #8: Add four walls without physics and using only one definition of the Shape node.</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">實際操作＃8：添加四面牆，無需物理操作，僅使用“形狀”節點的一個定義。</span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">Solution: World File<br/>To compare your world with the solution, go to your files and find the folder named "my_first_simulation" created in Tutorial 1, then go to the "worlds" folder and open with a text editor the right world. This solution as the others is located in the solution directory.<br/></span></div>
<div class="result-shield-container tlid-copy-target" tabindex="0"><span class="tlid-translation translation" lang="zh-TW">解決方案：世界文件<br/>要將您的世界與解決方案進行比較，請轉到文件，找到在教程1中創建的名為“ my_first_simulation”的文件夾，然後轉到“ worlds”文件夾，並使用文本編輯器打開正確的世界。與其他解決方案一樣，該解決方案位於解決方案目錄中。</span></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p><span style="color: #ff0000;"><big>w17個人任務</big></span></p>
<p><span></span></p><h1>Note</h1>
<p><span style="color: #ff0000;">git submodule add</span> https://github.com/mdecourse/cmsimde.git cmsimde 第一次把cmsimde載入倉儲使用<br/><span style="color: #ff0000;">python -m pip install flask_cors</span> 要更新下載flask_cors<br/><span style="color: #ff0000;">git clone --recurse-submodules</span> <span style="color: #00ff00;">https://github.com/solvespace/solvespace.git solvespace</span><br/>從遠端copy cmsimde必須，綠字部分改cmsimde的網址</p>
<p>使用學校網路需用proxy</p>
<p><span style="color: #ff0000;">[http]</span><br/><span style="color: #ff0000;"> proxy = [2001:288:6004:17::7]:3128</span></p>
<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>